# @Author: Eric Rosenthal
# @Date:   2022-06-08T11:15:28-07:00
# @Email:  ericros@stanford.edu
# @Project: nspyre-jv
# @Last modified by:   Eric Rosenthal
# @Last modified time: 2022-07-16T16:03:37-07:00




import logging
import time
from typing import Any
from typing import Dict

import pyqtgraph as pg
# from pyqtgraph.widgets import MatplotlibWidget
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import QSemaphore
from PyQt5.QtCore import QThread
from PyQt5.QtGui import QColor
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QVBoxLayout
from PyQt5.QtWidgets import QWidget

import sys
import params
path_name = params.PATH_PARAMS['nspyre_path']
sys.path.insert(0,r'{}\Utility\Style'.format(path_name))
from colors_matplotlib import colors
from colors_matplotlib import cyclic_colors
from style import nspyre_font

logger = logging.getLogger(__name__)

class WidgetUpdateThread(QThread):
    """Run update_func() repeatedly in a thread."""

    def __init__(self, update_func, report_fps=False, fps_period=1):
        """TODO"""
        super().__init__()
        self.update_func = update_func
        self.report_fps = report_fps
        self.fps_period = fps_period

    def run(self):
        """Thread entry point"""
        # keep track of how frequently update_func is called in the fps_period
        fps_counter = 0
        # time since the last reporting of the plot update FPS
        last_fps = time.time()
        while self.update_func:
            self.update_func()
            # calculate how many times per second update_func is being called
            if self.report_fps:
                fps_counter += 1
                now = time.time()
                # time difference since last FPS report
                td = now - last_fps
                if td > self.fps_period:
                    fps = fps_counter / td
                    logger.debug(f'plotting FPS: {fps:0.3f}')
                    last_fps = now
                    fps_counter = 0

class ColorPlotWidget(QWidget):

    new_data = pyqtSignal(str)

    def __init__(
        self,
        *args,
        title: str = '',
        xlabel: str = '',
        ylabel: str = '',
        zlabel: str = '',
        font: QFont = nspyre_font,
        **kwargs,
    ):
        """Initialize a LinePlotWidget.

        Args:
            title: Plot title.
            xlabel: Plot x-axis label.
            ylabel: Plot y-axis label.
            font: Font to use in the plot title, axis labels, etc., although the font type may not be fully honored.
        """
        super().__init__(*args, **kwargs)

        # layout for storing plot
        self.layout = QVBoxLayout()

        # testing 2022-07-13
        # from pyqtgraph.widgets import MatplotlibWidget
        print('testing MatplotlibWidget....')
        mw = MatplotlibWidget()
        subplot = mw.getFigure().add_subplot(111)
        x = [1,2,3,4,5]
        y = [1,4,9,16,25]
        subplot.plot(x,y)
        mw.draw()
        mw.show()

        # testing 2022-07-13
        print('testing ColorMapWidget...')
        self.plot_widget = pg.ColorMapWidget()
        self.layout.addWidget(self.plot_widget)

        print('PlotWidget code...')
        # pyqtgraph widget for displaying a plot and related
        # items like axes, legends, etc.
        # self.plot_widget = pg.PlotWidget()
        #
        # # self.plot_widget = pg.ColorMapWidget()
        # self.layout.addWidget(self.plot_widget)
        #
        # # plot settings
        # self.plot_widget.setTitle(title, size=f'{font.pointSize()}pt')
        # self.plot_widget.enableAutoRange(True)
        # # colors
        # self.current_color_idx = 0
        # self.plot_widget.setBackground(colors['black'])
        # self.plot_widget.showGrid(x=True, y=True, alpha=0.3)

        # legend
        # self.plot_widget.addLegend(labelTextSize=f'{font.pointSize()}pt')

        # a dict mapping data set names (str) and a sub-dict containing the x data, y data, semaphore, and pyqtgraph PlotDataItem associated with each line plot
        self.plots: Dict[str, Dict[str, Any]] = {}

        self.setLayout(self.layout)

        # plot setup code
        # self.setup()
        # thread for updating the plot data
        # self.update_thread = WidgetUpdateThread(self.update)
        # # process new data when a signal is generated by the update thread
        # self.new_data.connect(self._process_data)
        # # start the thread
        # self.update_thread.start()


        ############### working PlotWidget code below here... ############
        # print('PlotWidget code...')
        # # pyqtgraph widget for displaying a plot and related
        # # items like axes, legends, etc.
        # self.plot_widget = pg.PlotWidget()
        #
        # # self.plot_widget = pg.ColorMapWidget()
        # self.layout.addWidget(self.plot_widget)
        #
        # # plot settings
        # self.plot_widget.setTitle(title, size=f'{font.pointSize()}pt')
        # self.plot_widget.enableAutoRange(True)
        # # colors
        # self.current_color_idx = 0
        # self.plot_widget.setBackground(colors['black'])
        # # self.plot_widget.showGrid(x=True, y=True, alpha=0.3)
        #
        # # axes
        # self.xaxis = self.plot_widget.getAxis('bottom')
        # self.xaxis.setLabel(text=xlabel)
        # self.xaxis.label.setFont(font)
        # self.xaxis.setTickFont(font)
        # self.xaxis.enableAutoSIPrefix(False)
        # self.yaxis = self.plot_widget.getAxis('left')
        # self.yaxis.setLabel(text=ylabel)
        # self.yaxis.label.setFont(font)
        # self.yaxis.setTickFont(font)
        # self.yaxis.enableAutoSIPrefix(False)
        # # self.plot_widget.addColorBar()
        #
        # # legend
        # # self.plot_widget.addLegend(labelTextSize=f'{font.pointSize()}pt')
        #
        # # a dict mapping data set names (str) and a sub-dict containing the x data, y data, semaphore, and pyqtgraph PlotDataItem associated with each line plot
        # self.plots: Dict[str, Dict[str, Any]] = {}
        #
        # self.setLayout(self.layout)
        #
        # # plot setup code
        # self.setup()
        # # thread for updating the plot data
        # self.update_thread = WidgetUpdateThread(self.update)
        # # process new data when a signal is generated by the update thread
        # self.new_data.connect(self._process_data)
        # # start the thread
        # self.update_thread.start()

    def setup(self):
        """Subclasses should override this function to perform any setup code"""
        pass

    def update(self):
        """Subclasses should override this function to update the plot. This function will be run in a separate Thread."""
        time.sleep(0.1)
        # time.sleep(1)

    def teardown(self):
        """Subclasses should override this function to perform any teardown code"""
        pass

    def _next_color(self):
        """Cycle through a set of colors"""
        idx = self.current_color_idx % len(cyclic_colors)
        color = pg.mkColor(cyclic_colors[idx])
        self.current_color_idx += 1
        return color

    def new_plot(
        self,
        name: str,
        pen: QColor = None,
        symbolBrush=(255, 255, 255, 100),
        symbolPen=(255, 255, 255, 100),
        symbol: str = 's',
        symbolSize: int = 5,
    ):
        """Add a new plot to the PlotWidget.

        Args:
            name: Name of the plot.
            pen: See https://pyqtgraph.readthedocs.io/en/latest/graphicsItems/plotdataitem.html.
            symbolBrush: See https://pyqtgraph.readthedocs.io/en/latest/graphicsItems/plotdataitem.html.
            symbolPen: See https://pyqtgraph.readthedocs.io/en/latest/graphicsItems/plotdataitem.html.
            symbol: See https://pyqtgraph.readthedocs.io/en/latest/graphicsItems/plotdataitem.html.
            symbolSize: See https://pyqtgraph.readthedocs.io/en/latest/graphicsItems/plotdataitem.html.

        Raises:
            ValueError: An error with the supplied arguments.
        """
        if name in self.plots:
            raise ValueError(f'A plot with the name {name} already exists.')

        if not pen:
            pen = self._next_color()

        # create pyqtgraph PlotDataItem
        plt = self.plot_widget.plot(
            pen=pen,
            symbolBrush=symbolBrush,
            symbolPen=symbolPen,
            symbol=symbol,
            symbolSize=symbolSize,
            name=name,
        )
        # self.plots[name] = {'x': [], 'y': [], 'plot': plt, 'sem': QSemaphore(n=1)}
        self.plots[name] = {'x':[], 'y':[], 'z':[], 'plot': plt, 'sem': QSemaphore(n=1)}

    def set_data(self, name: str, xdata, ydata, zdata):
        """Queue up x/y/z data to update a color plot. Threadsafe.

        Args:
            name: Name of the plot.
            xdata: array-like of data for the x-axis.
            ydata: array-like of data for the y-axis.
            zdata: array-like of data for the z-axis.

        Raises:
            ValueError: An error with the supplied arguments.
        """
        if name not in self.plots:
            raise ValueError(f'A plot with the name {name} does not exist.')

        # block until any previous calls to set_data have been fully processed
        self.plots[name]['sem'].acquire()
        # set the new x and y data
        self.plots[name]['x'] = xdata
        self.plots[name]['y'] = ydata
        self.plots[name]['z'] = zdata
        # notify the watcher
        try:
            self.parent()
        except RuntimeError:
            # this Qt object has already been deleted
            return
        else:
            # notify that new data is available
            self.new_data.emit(name)

    def _process_data(self, name):
        """Update a line plot triggered by set_data."""
        try:
            self.plots[name]['plot'].setData(
                self.plots[name]['x'], self.plots[name]['y'], self.plots[name]['z']
            )
        except Exception as exc:
            raise exc
        finally:
            self.plots[name]['sem'].release()

    def add_zoom_region(self):
        """Create a GUI element for selecting a plot subregion. Returns a new PlotWidget that contains a view with it's x span linked to the area selected by the plot subregion."""
        # current display region
        plot_xrange, plot_yrange = self.plot_widget.viewRange()
        xmin, xmax = plot_xrange
        center = (xmax + xmin) / 2
        span = (xmax - xmin) / 20
        # create GUI element for subregion selection
        linear_region = pg.LinearRegionItem(values=[center - span, center + span])
        self.plot_widget.addItem(linear_region)

    def stop(self):
        self.update_thread.update_func = None
        self.teardown()

import matplotlib
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
# from ..Qt import QtWidgets
__all__ = ['MatplotlibWidget']
class MatplotlibWidget(QWidget):
    """
    Implements a Matplotlib figure inside a QWidget.
    Use getFigure() and redraw() to interact with matplotlib.

    Example::

        mw = MatplotlibWidget()
        subplot = mw.getFigure().add_subplot(111)
        subplot.plot(x,y)
        mw.draw()
    """

    def __init__(self, size=(5.0, 4.0), dpi=100):
        QWidget.__init__(self)
        self.fig = Figure(size, dpi=dpi)
        self.canvas = FigureCanvas(self.fig)
        self.canvas.setParent(self)
        self.toolbar = NavigationToolbar(self.canvas, self)

        # self.vbox = QWidget.QVBoxLayout()
        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.toolbar)
        self.vbox.addWidget(self.canvas)
        self.setLayout(self.vbox)

    def getFigure(self):
        return self.fig

    def draw(self):
        self.canvas.draw()

    def show(self):
        self.canvas.show()
